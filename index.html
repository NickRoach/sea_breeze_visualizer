<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Sea Breeze Visualiser</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; }

    #controls {
      position: absolute;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      background: rgba(255,255,255,0.95);
      padding: 8px 10px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      font-family: system-ui, sans-serif;
      font-size: 14px;
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .modeBtn {
      padding: 6px 12px;
      border-radius: 8px;
      border: 1px solid #bbb;
      background: #f3f3f3;
      cursor: pointer;
    }

    .modeBtn.selected {
      background: #111;
      color: #fff;
      border-color: #111;
    }

    .spinner {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 48px;
      height: 48px;
      margin: -24px 0 0 -24px;
      border: 5px solid rgba(0,0,0,0.15);
      border-top-color: #111;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      z-index: 2000;
      pointer-events: none;
    }

    .spinner.hidden { display: none; }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body>

<div id="map"></div>
<div id="spinner" class="spinner hidden"></div>

<div id="controls">
  <button id="qBtn" class="modeBtn selected">Specific humidity</button>
  <button id="humBtn" class="modeBtn">Relative humidity</button>
  <button id="tempBtn" class="modeBtn">Temperature</button>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
  // ---- MAP ----
  const map = L.map("map").setView([-33.645239, 150.556535], 9);

  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    attribution: "© OpenStreetMap contributors",
    maxZoom: 17
  }).addTo(map);

  const layer = L.layerGroup().addTo(map);

  // ---- UI ----
  const spinner = document.getElementById("spinner");
  function showSpinner() { spinner.classList.remove("hidden"); }
  function hideSpinner() { spinner.classList.add("hidden"); }

  const qBtn = document.getElementById("qBtn");
  const humBtn = document.getElementById("humBtn");
  const tempBtn = document.getElementById("tempBtn");

  let colorMode = "q"; // "q" | "humidity" | "temp"

  function setMode(mode) {
    colorMode = mode;
    qBtn.classList.toggle("selected", mode === "q");
    humBtn.classList.toggle("selected", mode === "humidity");
    tempBtn.classList.toggle("selected", mode === "temp");
    loadData();
  }

  qBtn.onclick = () => setMode("q");
  humBtn.onclick = () => setMode("humidity");
  tempBtn.onclick = () => setMode("temp");

  // ---- CONSTANTS ----
  const WINDOW_MS = 15 * 60 * 1000;
  const cache = new Map();

  // median-centered ranges
  const TEMP_RANGE_C = 10;     // total span
  const HUM_RANGE_PCT = 20;    // total span
  const Q_RANGE_GKG = 5;       // total span

  // outlier filtering
  const OUTLIER_K = 2.5;

  // ---- MATH / HELPERS ----
  function fToC(f) { return (f - 32) * 5 / 9; }

  function inHgToHpa(inHg) {
    return (typeof inHg === "number") ? inHg * 33.8638866667 : null;
  }

  function specificHumidityGkg(tempC, rh, pressureHpa) {
    if (typeof tempC !== "number" || typeof rh !== "number" || typeof pressureHpa !== "number") return null;
    const es = 6.112 * Math.exp((17.67 * tempC) / (tempC + 243.5)); // hPa
    const e  = (rh / 100) * es;                                     // hPa
    const q  = (0.622 * e) / (pressureHpa - 0.378 * e);             // kg/kg
    return q * 1000; // g/kg
  }

  function getLatLon(f) {
    const c = f?.geometry?.coordinates;
    return (Array.isArray(c) && c.length >= 2) ? [c[1], c[0]] : null;
  }

  function ageToOpacity(validTimeMs) {
    if (typeof validTimeMs !== "number") return 0;
    const ageMs = Date.now() - validTimeMs;
    const maxAge = 30 * 60 * 1000;
    const f = 1 - (ageMs / maxAge);
    return Math.max(0, Math.min(1, f));
  }

  function floorToQuarterHour(ms) {
    const d = new Date(ms);
    d.setSeconds(0, 0);
    d.setMinutes(d.getMinutes() - (d.getMinutes() % 15));
    return d.getTime();
  }

  function meanSd(vals) {
    const a = vals.filter(v => typeof v === "number" && Number.isFinite(v));
    const n = a.length;
    if (n < 2) return { mean: null, sd: null };
    const mean = a.reduce((s, v) => s + v, 0) / n;
    const varPop = a.reduce((s, v) => s + (v - mean) * (v - mean), 0) / n;
    return { mean, sd: Math.sqrt(varPop) };
  }

  function median(vals) {
    const a = vals.filter(v => typeof v === "number" && Number.isFinite(v)).sort((x, y) => x - y);
    const n = a.length;
    if (!n) return null;
    const mid = Math.floor(n / 2);
    return (n % 2) ? a[mid] : (a[mid - 1] + a[mid]) / 2;
  }

  function clamp01(x) { return Math.max(0, Math.min(1, x)); }

// low = blue, high = red (keep for temperature)
function blueToRed(v, vMin, vMax) {
  if (typeof v !== "number" || vMin == null || vMax == null || vMax === vMin) return "#888";
  const f = Math.max(0, Math.min(1, (v - vMin) / (vMax - vMin)));
  return `rgb(${Math.round(255*f)},0,${Math.round(255*(1-f))})`;
}

// low = red, high = blue (use for humidity + specific humidity)
function redToBlue(v, vMin, vMax) {
  if (typeof v !== "number" || vMin == null || vMax == null || vMax === vMin) return "#888";
  const f = Math.max(0, Math.min(1, (v - vMin) / (vMax - vMin)));
  return `rgb(${Math.round(255*(1-f))},0,${Math.round(255*f)})`;
}


  // ---- OUTLIER FILTERING (temp + RH + q) ----
  function filterOutliersByStd(features) {
    const temps = [];
    const hums = [];
    const qs = [];

    for (const f of features) {
      const p = f.properties || {};
      const t = (typeof p.tempf === "number") ? fToC(p.tempf) : null;
      const h = (typeof p.humidity === "number") ? p.humidity : null;
      const pHpa = inHgToHpa(p.baromin);
      const q = (typeof t === "number" && typeof h === "number" && typeof pHpa === "number")
        ? specificHumidityGkg(t, h, pHpa)
        : null;

      if (typeof t === "number") temps.push(t);
      if (typeof h === "number") hums.push(h);
      if (typeof q === "number") qs.push(q);
    }

    const tStats = meanSd(temps);
    const hStats = meanSd(hums);
    const qStats = meanSd(qs);

    const tLo = (tStats.mean != null && tStats.sd != null) ? tStats.mean - OUTLIER_K * tStats.sd : -Infinity;
    const tHi = (tStats.mean != null && tStats.sd != null) ? tStats.mean + OUTLIER_K * tStats.sd :  Infinity;

    const hLo = (hStats.mean != null && hStats.sd != null) ? hStats.mean - OUTLIER_K * hStats.sd : -Infinity;
    const hHi = (hStats.mean != null && hStats.sd != null) ? hStats.mean + OUTLIER_K * hStats.sd :  Infinity;

    const qLo = (qStats.mean != null && qStats.sd != null) ? qStats.mean - OUTLIER_K * qStats.sd : -Infinity;
    const qHi = (qStats.mean != null && qStats.sd != null) ? qStats.mean + OUTLIER_K * qStats.sd :  Infinity;

    return features.filter(f => {
      const p = f.properties || {};
      const t = (typeof p.tempf === "number") ? fToC(p.tempf) : null;
      const h = (typeof p.humidity === "number") ? p.humidity : null;
      const pHpa = inHgToHpa(p.baromin);
      const q = (typeof t === "number" && typeof h === "number" && typeof pHpa === "number")
        ? specificHumidityGkg(t, h, pHpa)
        : null;

      if (typeof t !== "number" || typeof h !== "number" || typeof q !== "number") return false;

      return (t >= tLo && t <= tHi) && (h >= hLo && h <= hHi) && (q >= qLo && q <= qHi);
    });
  }

  // ---- MEDIAN-CENTERED RANGES ----
  let tempMin=null, tempMax=null, humMin=null, humMax=null, qMin=null, qMax=null;

  function computeRanges(features) {
    const temps = [];
    const hums = [];
    const qs = [];

    for (const f of features) {
      const p = f.properties || {};
      const t = (typeof p.tempf === "number") ? fToC(p.tempf) : null;
      const h = (typeof p.humidity === "number") ? p.humidity : null;
      const pHpa = inHgToHpa(p.baromin);
      const q = (typeof t === "number" && typeof h === "number" && typeof pHpa === "number")
        ? specificHumidityGkg(t, h, pHpa)
        : null;

      if (typeof t === "number") temps.push(t);
      if (typeof h === "number") hums.push(h);
      if (typeof q === "number") qs.push(q);
    }

    const tMed = median(temps);
    const hMed = median(hums);
    const qMed = median(qs);

    const tHalf = TEMP_RANGE_C / 2;
    const hHalf = HUM_RANGE_PCT / 2;
    const qHalf = Q_RANGE_GKG / 2;

    tempMin = (tMed == null) ? null : tMed - tHalf;
    tempMax = (tMed == null) ? null : tMed + tHalf;

    humMin  = (hMed == null) ? null : hMed - hHalf;
    humMax  = (hMed == null) ? null : hMed + hHalf;

    qMin    = (qMed == null) ? null : qMed - qHalf;
    qMax    = (qMed == null) ? null : qMed + qHalf;
  }

  function tempToColor(t)      { return blueToRed(t, tempMin, tempMax); }
function humidityToColor(h)  { return redToBlue(h, humMin, humMax); }
function qToColor(q)         { return redToBlue(q, qMin, qMax); }


  // ---- Multi-resolution tile fetching ----
  async function fetchFeaturesForGrid(startMs, endMs, { startX, startY, tilesX, tilesY, lod }) {
    const key = `${startMs}-${endMs}:${startX},${startY},${tilesX},${tilesY},lod${lod}`;
    if (cache.has(key)) return cache.get(key);

    let features = [];
    for (let x = startX; x <= startX + tilesX; x++) {
      for (let y = startY; y <= startY + tilesY; y++) {
        const url =
          `https://api.weather.com/v2/vector-api/products/614/features` +
          `?x=${x}&y=${y}&lod=${lod}&apiKey=e1f10a1e78da46f5b10a1e78da96f525` +
          `&tile-size=512&time=${startMs}-${endMs}`;

        const r = await fetch(url);
        const j = await r.json();
        features = features.concat(j.features);
      }
    }

    cache.set(key, features);
    return features;
  }

  const TILE_REQUESTS = [
  { startX: 1879, startY: 1226, tilesX: 1, tilesY: 1, lod: 12 }, // blue mountains hi-res
  { startX: 939,  startY: 613,  tilesX: 1, tilesY: 1, lod: 11 }, 
  //{ startX: 469,  startY: 306,  tilesX: 1, tilesY: 1, lod: 10 },
  { startX: 234,  startY: 152,  tilesX: 2, tilesY: 2, lod: 9 },
  { startX: 28,  startY: 18,  tilesX: 1, tilesY: 1, lod: 6 },
];


  async function fetchFeaturesMerged(startMs, endMs) {
    const tasks = TILE_REQUESTS.map(cfg =>
      fetchFeaturesForGrid(startMs, endMs, cfg)
    );

    const buckets = await Promise.all(tasks);

    return buckets.flat();
  }


  function mostRecentPerStation(features, startMs, endMs) {
    const byId = new Map();

    for (const f of features) {
      const id = f?.id || f?.properties?.id;
      const vt = f?.properties?.validTime;
      if (!id || typeof vt !== "number") continue;
      if (vt < startMs || vt > endMs) continue;

      const prev = byId.get(id);
      if (!prev || vt > prev.properties.validTime) byId.set(id, f);
    }

    return [...byId.values()];
  }

  async function loadData() {
    showSpinner();
    try {
      const start = floorToQuarterHour(Date.now());
      const end = start + WINDOW_MS;
      const prevStart = start - WINDOW_MS;

      const [bucketPrev, bucketNow] = await Promise.all([
        fetchFeaturesMerged(prevStart, start),
        fetchFeaturesMerged(start, end)
      ]);

      const latest = mostRecentPerStation(bucketPrev.concat(bucketNow), prevStart, end);

      // outlier filtering first
      const filtered = filterOutliersByStd(latest);

      // median-centered ranges next
      computeRanges(filtered);

      layer.clearLayers();

      for (const f of filtered) {
        const ll = getLatLon(f);
        if (!ll) continue;

        const p = f.properties || {};
        const t = (typeof p.tempf === "number") ? fToC(p.tempf) : null;
        const h = (typeof p.humidity === "number") ? p.humidity : null;
        const pHpa = inHgToHpa(p.baromin);
        const q = (typeof t === "number" && typeof h === "number" && typeof pHpa === "number")
          ? specificHumidityGkg(t, h, pHpa)
          : null;

        const fillColor =
          (colorMode === "q") ? qToColor(q) :
          (colorMode === "humidity") ? humidityToColor(h) :
          tempToColor(t);

        const op = ageToOpacity(p.validTime);
        if (op <= 0) continue;

        L.circleMarker(ll, {
          radius: 9,
          fillColor,
          color: "#000",
          weight: 0,
          fillOpacity: op
        })
        .bindPopup(
          `<strong>${p.neighborhood ?? f.id}</strong><br>
          Spec. humidity: ${q !== null ? q.toFixed(1) : "—"} g/kg<br>
           Rel. humidity: ${h !== null ? h : "—"} %<br>
           Temp: ${t !== null ? t.toFixed(1) : "—"} °C<br>
           Updated: ${
            p.validTime
              ? new Date(p.validTime).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })
              : "—"
          }`
        )
        .addTo(layer);
      }
    } finally {
      hideSpinner();
    }
  }

  loadData();
</script>

</body>
</html>
