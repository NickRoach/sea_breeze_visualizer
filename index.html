<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Sea Breeze Visualiser</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; }

    #controls {
      position: absolute;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      background: rgba(255,255,255,0.95);
      padding: 8px 10px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      font-family: system-ui, sans-serif;
      font-size: 14px;
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .modeBtn {
      padding: 6px 12px;
      border-radius: 8px;
      border: 1px solid #bbb;
      background: #f3f3f3;
      cursor: pointer;
    }

    .modeBtn.selected {
      background: #111;
      color: #fff;
      border-color: #111;
    }
  </style>
</head>
<body>

<div id="map"></div>

<div id="controls">
  <button id="humBtn" class="modeBtn selected">Humidity</button>
  <button id="tempBtn" class="modeBtn">Temp</button>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
  const map = L.map("map").setView([-33.645239, 150.556535], 11);

  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    attribution: "© OpenStreetMap contributors",
    maxZoom: 19
  }).addTo(map);

  const layer = L.layerGroup().addTo(map);

  const startX = 1878;
  const startY = 1226;

  const WINDOW_MS = 15 * 60 * 1000;
  const cache = new Map();

  let colorMode = "humidity"; // "humidity" | "temp"

  const humBtn = document.getElementById("humBtn");
  const tempBtn = document.getElementById("tempBtn");

  function setMode(mode) {
    colorMode = mode;
    humBtn.classList.toggle("selected", mode === "humidity");
    tempBtn.classList.toggle("selected", mode === "temp");
    loadData();
  }

  humBtn.onclick = () => setMode("humidity");
  tempBtn.onclick = () => setMode("temp");

  function fToC(f) { return (f - 32) * 5 / 9; }

  function getLatLon(f) {
    const c = f?.geometry?.coordinates;
    if (!Array.isArray(c) || c.length < 2) return null;
    return [c[1], c[0]];
  }

  // ---- OUTLIER REMOVAL (std dev) ----
  const OUTLIER_K = 2.5; // keep values within mean ± K*sd

  function meanSd(vals) {
    const n = vals.length;
    if (n < 2) return { mean: null, sd: null };
    const mean = vals.reduce((a, b) => a + b, 0) / n;
    const varPop = vals.reduce((a, b) => a + (b - mean) * (b - mean), 0) / n;
    const sd = Math.sqrt(varPop);
    return { mean, sd };
  }

  function filterOutliersByStd(features) {
    const temps = [];
    const hums = [];

    for (const f of features) {
      const p = f.properties || {};
      if (typeof p.tempf === "number") temps.push(fToC(p.tempf));
      if (typeof p.humidity === "number") hums.push(p.humidity);
    }

    const tStats = meanSd(temps);
    const hStats = meanSd(hums);

    const tLo = (tStats.mean != null && tStats.sd != null) ? tStats.mean - OUTLIER_K * tStats.sd : -Infinity;
    const tHi = (tStats.mean != null && tStats.sd != null) ? tStats.mean + OUTLIER_K * tStats.sd :  Infinity;
    const hLo = (hStats.mean != null && hStats.sd != null) ? hStats.mean - OUTLIER_K * hStats.sd : -Infinity;
    const hHi = (hStats.mean != null && hStats.sd != null) ? hStats.mean + OUTLIER_K * hStats.sd :  Infinity;

    return features.filter(f => {
      const p = f.properties || {};
      const t = (typeof p.tempf === "number") ? fToC(p.tempf) : null;
      const h = (typeof p.humidity === "number") ? p.humidity : null;
      if (typeof t !== "number" || typeof h !== "number") return false;
      return (t >= tLo && t <= tHi && h >= hLo && h <= hHi);
    });
  }

  // dynamic ranges, recomputed each load to maximize contrast
  let tempMin = null, tempMax = null;
  let humMin = null, humMax = null;

  function computeRanges(features) {
    tempMin = Infinity; tempMax = -Infinity;
    humMin = Infinity; humMax = -Infinity;

    for (const f of features) {
      const p = f.properties || {};
      const t = (typeof p.tempf === "number") ? fToC(p.tempf) : null;
      const h = (typeof p.humidity === "number") ? p.humidity : null;

      if (typeof t === "number") { tempMin = Math.min(tempMin, t); tempMax = Math.max(tempMax, t); }
      if (typeof h === "number") { humMin = Math.min(humMin, h); humMax = Math.max(humMax, h); }
    }

    if (!Number.isFinite(tempMin) || !Number.isFinite(tempMax)) { tempMin = null; tempMax = null; }
    if (!Number.isFinite(humMin)  || !Number.isFinite(humMax))  { humMin  = null; humMax  = null; }
  }

  // TEMP: lowest = blue, highest = red
  function tempToColor(t) {
    if (typeof t !== "number" || tempMin == null || tempMax == null) return "#888";
    if (tempMax === tempMin) return "rgb(128,0,128)";
    const f = (t - tempMin) / (tempMax - tempMin); // 0..1
    const r = Math.round(255 * f);
    const g = 0;
    const b = Math.round(255 * (1 - f));
    return `rgb(${r},${g},${b})`;
  }

  // HUMIDITY: lowest = red, highest = blue
  function humidityToColor(h) {
    if (typeof h !== "number" || humMin == null || humMax == null) return "#888";
    if (humMax === humMin) return "rgb(128,0,128)";
    const f = (h - humMin) / (humMax - humMin); // 0..1
    const r = Math.round(255 * (1 - f));
    const g = 0;
    const b = Math.round(255 * f);
    return `rgb(${r},${g},${b})`;
  }

  function floorToQuarterHour(ms) {
    const d = new Date(ms);
    d.setSeconds(0, 0);
    d.setMinutes(d.getMinutes() - (d.getMinutes() % 15));
    return d.getTime();
  }

  async function fetchFeatures(startMs, endMs) {
    const key = `${startMs}-${endMs}`;
    if (cache.has(key)) return cache.get(key);

    let features = [];
    for (let x = startX; x <= startX + 3; x++) {
      for (let y = startY; y <= startY + 2; y++) {
        const url =
          `https://api.weather.com/v2/vector-api/products/614/features` +
          `?x=${x}&y=${y}&lod=12&apiKey=e1f10a1e78da46f5b10a1e78da96f525` +
          `&tile-size=512&time=${startMs}-${endMs}`;

        const r = await fetch(url);
        const j = await r.json();
        features = features.concat(j.features);
      }
    }
    cache.set(key, features);
    return features;
  }

  function mostRecentPerStation(features, startMs, endMs) {
    const byId = new Map();

    for (const f of features) {
      const id = f?.id || f?.properties?.id;
      const vt = f?.properties?.validTime;
      if (!id || typeof vt !== "number") continue;
      if (vt < startMs || vt > endMs) continue;

      const p = f.properties || {};
      if (typeof p.humidity !== "number") continue;
      if (typeof p.tempf !== "number") continue;

      const prev = byId.get(id);
      if (!prev || vt > prev.properties.validTime) byId.set(id, f);
    }

    return [...byId.values()];
  }

  async function loadData() {
    const end = floorToQuarterHour(Date.now());
    const start = end - WINDOW_MS;

    const bucket = await fetchFeatures(start, end);
    const latest = mostRecentPerStation(bucket, start, end);

    // remove outliers (temp + humidity) before computing min/max + drawing
    const features = filterOutliersByStd(latest);

    computeRanges(features);

    layer.clearLayers();
    const pts = [];

    for (const f of features) {
      const ll = getLatLon(f);
      if (!ll) continue;

      const p = f.properties || {};
      const t = (typeof p.tempf === "number") ? fToC(p.tempf) : null;
      const h = (typeof p.humidity === "number") ? p.humidity : null;

      const fillColor =
        (colorMode === "humidity") ? humidityToColor(h) : tempToColor(t);

      L.circleMarker(ll, {
        radius: 9,
        fillColor,
        color: "#000",
        weight: 0,
        fillOpacity: 0.85
      })
      .bindPopup(
        `<strong>${p.neighborhood ?? f.id}</strong><br>
         Temp: ${t !== null ? t.toFixed(1) : "—"} °C<br>
         Humidity: ${h !== null ? h : "—"} %<br>
         Updated: ${
          p.validTime
            ? new Date(p.validTime).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })
            : "—"
        }`
      )
      .addTo(layer);

      pts.push(ll);
    }

    if (pts.length) map.fitBounds(pts, { padding: [-20, -20] });
  }

  loadData();
</script>

</body>
</html>
